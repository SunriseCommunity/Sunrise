// Automatically generated by Interoptopus.

#pragma warning disable 0105
using System.Collections;
using System.Runtime.InteropServices;

#pragma warning restore 0105

namespace RosuPP;

public static class Rosu
{
    public const string NativeLib = "rosu_pp_ffi";


    /// Destroys the given instance.
    /// 
    /// # Safety
    /// 
    /// The passed parameter MUST have been created with the corresponding init function;
    /// passing any other value results in undefined behavior.
    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "beatmap_attributes_destroy")]
    public static extern FFIError beatmap_attributes_destroy(ref IntPtr context);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "beatmap_attributes_new")]
    public static extern FFIError beatmap_attributes_new(ref IntPtr context);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "beatmap_attributes_mode")]
    public static extern void beatmap_attributes_mode(IntPtr context, Mode mode);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "beatmap_attributes_p_mods")]
    public static extern void beatmap_attributes_p_mods(IntPtr context, IntPtr mods);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "beatmap_attributes_i_mods")]
    public static extern void beatmap_attributes_i_mods(IntPtr context, uint mods);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "beatmap_attributes_s_mods")]
    public static extern FFIError beatmap_attributes_s_mods(IntPtr context, string str);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "beatmap_attributes_clock_rate")]
    public static extern void beatmap_attributes_clock_rate(IntPtr context, double clock_rate);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "beatmap_attributes_ar")]
    public static extern void beatmap_attributes_ar(IntPtr context, float ar);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "beatmap_attributes_cs")]
    public static extern void beatmap_attributes_cs(IntPtr context, float cs);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "beatmap_attributes_hp")]
    public static extern void beatmap_attributes_hp(IntPtr context, float hp);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "beatmap_attributes_od")]
    public static extern void beatmap_attributes_od(IntPtr context, float od);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "beatmap_attributes_get_clock_rate")]
    public static extern double beatmap_attributes_get_clock_rate(IntPtr context);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "beatmap_attributes_build")]
    public static extern BeatmapAttributes beatmap_attributes_build(IntPtr context, IntPtr beatmap);

    /// Destroys the given instance.
    /// 
    /// # Safety
    /// 
    /// The passed parameter MUST have been created with the corresponding init function;
    /// passing any other value results in undefined behavior.
    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "beatmap_destroy")]
    public static extern FFIError beatmap_destroy(ref IntPtr context);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "beatmap_from_bytes")]
    public static extern FFIError beatmap_from_bytes(ref IntPtr context, Sliceu8 data);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "beatmap_from_path")]
    public static extern FFIError beatmap_from_path(ref IntPtr context, string path);

    /// Convert a BeatmapFile to the specified mode
    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "beatmap_convert")]
    public static extern bool beatmap_convert(IntPtr context, Mode mode);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "beatmap_bpm")]
    public static extern double beatmap_bpm(IntPtr context);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "beatmap_total_break_time")]
    public static extern double beatmap_total_break_time(IntPtr context);

    /// Destroys the given instance.
    /// 
    /// # Safety
    /// 
    /// The passed parameter MUST have been created with the corresponding init function;
    /// passing any other value results in undefined behavior.
    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "difficulty_destroy")]
    public static extern FFIError difficulty_destroy(ref IntPtr context);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "difficulty_new")]
    public static extern FFIError difficulty_new(ref IntPtr context);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "difficulty_p_mods")]
    public static extern void difficulty_p_mods(IntPtr context, IntPtr mods);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "difficulty_i_mods")]
    public static extern void difficulty_i_mods(IntPtr context, uint mods);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "difficulty_s_mods")]
    public static extern FFIError difficulty_s_mods(IntPtr context, string str);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "difficulty_passed_objects")]
    public static extern void difficulty_passed_objects(IntPtr context, uint passed_objects);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "difficulty_clock_rate")]
    public static extern void difficulty_clock_rate(IntPtr context, double clock_rate);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "difficulty_ar")]
    public static extern void difficulty_ar(IntPtr context, float ar);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "difficulty_cs")]
    public static extern void difficulty_cs(IntPtr context, float cs);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "difficulty_hp")]
    public static extern void difficulty_hp(IntPtr context, float hp);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "difficulty_od")]
    public static extern void difficulty_od(IntPtr context, float od);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "difficulty_hardrock_offsets")]
    public static extern void difficulty_hardrock_offsets(IntPtr context, bool hardrock_offsets);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "difficulty_calculate")]
    public static extern DifficultyAttributes difficulty_calculate(IntPtr context, IntPtr beatmap);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "difficulty_get_clock_rate")]
    public static extern double difficulty_get_clock_rate(IntPtr context);

    /// Destroys the given instance.
    /// 
    /// # Safety
    /// 
    /// The passed parameter MUST have been created with the corresponding init function;
    /// passing any other value results in undefined behavior.
    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_destroy")]
    public static extern FFIError performance_destroy(ref IntPtr context);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_new")]
    public static extern FFIError performance_new(ref IntPtr context);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_mode")]
    public static extern void performance_mode(IntPtr context, Mode mode);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_p_mods")]
    public static extern void performance_p_mods(IntPtr context, IntPtr mods);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_i_mods")]
    public static extern void performance_i_mods(IntPtr context, uint mods);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_s_mods")]
    public static extern FFIError performance_s_mods(IntPtr context, string str);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_passed_objects")]
    public static extern void performance_passed_objects(IntPtr context, uint passed_objects);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_clock_rate")]
    public static extern void performance_clock_rate(IntPtr context, double clock_rate);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_ar")]
    public static extern void performance_ar(IntPtr context, float ar);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_cs")]
    public static extern void performance_cs(IntPtr context, float cs);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_hp")]
    public static extern void performance_hp(IntPtr context, float hp);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_od")]
    public static extern void performance_od(IntPtr context, float od);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_accuracy")]
    public static extern void performance_accuracy(IntPtr context, double accuracy);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_misses")]
    public static extern void performance_misses(IntPtr context, uint misses);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_combo")]
    public static extern void performance_combo(IntPtr context, uint combo);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_hitresult_priority")]
    public static extern void performance_hitresult_priority(IntPtr context, HitResultPriority hitresult_priority);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_n300")]
    public static extern void performance_n300(IntPtr context, uint n300);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_n100")]
    public static extern void performance_n100(IntPtr context, uint n100);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_n50")]
    public static extern void performance_n50(IntPtr context, uint n50);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_n_katu")]
    public static extern void performance_n_katu(IntPtr context, uint n_katu);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_generate_state")]
    public static extern ScoreState performance_generate_state(IntPtr context, IntPtr beatmap);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_calculate")]
    public static extern PerformanceAttributes performance_calculate(IntPtr context, IntPtr beatmap);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_calculate_from_difficulty")]
    public static extern PerformanceAttributes performance_calculate_from_difficulty(IntPtr context, DifficultyAttributes difficulty_attr);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_get_clock_rate")]
    public static extern double performance_get_clock_rate(IntPtr context);

    /// Destroys the given instance.
    /// 
    /// # Safety
    /// 
    /// The passed parameter MUST have been created with the corresponding init function;
    /// passing any other value results in undefined behavior.
    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "string_destroy")]
    public static extern FFIError string_destroy(ref IntPtr context);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "string_from_c_str")]
    public static extern FFIError string_from_c_str(ref IntPtr context, string str);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "string_empty")]
    public static extern FFIError string_empty(ref IntPtr context);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "string_is_init")]
    public static extern bool string_is_init(IntPtr context);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "string_to_cstr")]
    public static extern IntPtr string_to_cstr(IntPtr context);

    /// Destroys the given instance.
    /// 
    /// # Safety
    /// 
    /// The passed parameter MUST have been created with the corresponding init function;
    /// passing any other value results in undefined behavior.
    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "mods_destroy")]
    public static extern FFIError mods_destroy(ref IntPtr context);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "mods_from_acronyms")]
    public static extern FFIError mods_from_acronyms(ref IntPtr context, string str);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "mods_from_bits")]
    public static extern FFIError mods_from_bits(ref IntPtr context, uint bits);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "mods_bits")]
    public static extern uint mods_bits(IntPtr context);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "mods_is_empty")]
    public static extern bool mods_is_empty(IntPtr context);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "mods_contains")]
    public static extern bool mods_contains(IntPtr context, string str);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "mods_intersects")]
    public static extern bool mods_intersects(IntPtr context, string str);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "mods_legacy_clock_rate")]
    public static extern float mods_legacy_clock_rate(IntPtr context);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "debug_difficylty_attributes")]
    public static extern void debug_difficylty_attributes(ref DifficultyAttributes res, IntPtr str);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "debug_performance_attributes")]
    public static extern void debug_performance_attributes(ref PerformanceAttributes res, IntPtr str);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "debug_score_state")]
    public static extern void debug_score_state(ref ScoreState res, IntPtr str);
}

public enum HitResultPriority
{
    BestCase = 0,
    WorstCase = 1
}

public enum Mode
{
    /// osu!standard
    Osu = 0,

    /// osu!taiko
    Taiko = 1,

    /// osu!catch
    Catch = 2,

    /// osu!mania
    Mania = 3
}

/// Summary struct for a [`BeatmapFile`]'s attributes.
[Serializable]
[StructLayout(LayoutKind.Sequential)]
public struct BeatmapAttributes
{
    /// The approach rate.
    public double ar;

    /// The overall difficulty.
    public double od;

    /// The circle size.
    public double cs;

    /// The health drain rate
    public double hp;

    /// The clock rate with respect to mods.
    public double clock_rate;

    /// The hit windows for approach rate and overall difficulty.
    public HitWindows hit_windows;
}

/// The result of a difficulty calculation on an osu!catch map.
[Serializable]
[StructLayout(LayoutKind.Sequential)]
public struct CatchDifficultyAttributes
{
    /// The final star rating
    public double stars;

    /// The approach rate.
    public double ar;

    /// The amount of fruits.
    public uint n_fruits;

    /// The amount of droplets.
    public uint n_droplets;

    /// The amount of tiny droplets.
    public uint n_tiny_droplets;

    /// Whether the [`BeatmapFile`] was a convert i.e. an osu!standard map.
    /// 
    /// [`BeatmapFile`]: crate::model::beatmapFile::BeatmapFile
    [MarshalAs(UnmanagedType.I1)] public bool is_convert;
}

/// The result of a performance calculation on an osu!catch map.
[Serializable]
[StructLayout(LayoutKind.Sequential)]
public struct CatchPerformanceAttributes
{
    /// The difficulty attributes that were used for the performance calculation
    public CatchDifficultyAttributes difficulty;

    /// The final performance points.
    public double pp;
}

[Serializable]
[StructLayout(LayoutKind.Sequential)]
public struct DifficultyAttributes
{
    public OptionOsuDifficultyAttributes osu;
    public OptionTaikoDifficultyAttributes taiko;
    public OptionCatchDifficultyAttributes fruit;
    public OptionManiaDifficultyAttributes mania;
    public Mode mode;
}

/// AR and OD hit windows
[Serializable]
[StructLayout(LayoutKind.Sequential)]
public struct HitWindows
{
    /// Hit window for approach rate i.e. `TimePreempt` in milliseconds.
    public double ar;

    /// Hit window for overall difficulty i.e. time to hit a 300 ("Great") in milliseconds.
    public double od;
}

/// The result of a difficulty calculation on an osu!mania map.
[Serializable]
[StructLayout(LayoutKind.Sequential)]
public struct ManiaDifficultyAttributes
{
    /// The final star rating.
    public double stars;

    /// The perceived hit window for an n300 inclusive of rate-adjusting mods (DT/HT/etc).
    public double hit_window;

    /// The amount of hitobjects in the map.
    public uint n_objects;

    /// The maximum achievable combo.
    public uint max_combo;

    /// Whether the [`BeatmapFile`] was a convert i.e. an osu!standard map.
    /// 
    /// [`BeatmapFile`]: crate::model::beatmapFile::BeatmapFile
    [MarshalAs(UnmanagedType.I1)] public bool is_convert;
}

/// The result of a performance calculation on an osu!mania map.
[Serializable]
[StructLayout(LayoutKind.Sequential)]
public struct ManiaPerformanceAttributes
{
    /// The difficulty attributes that were used for the performance calculation.
    public ManiaDifficultyAttributes difficulty;

    /// The final performance points.
    public double pp;

    /// The difficulty portion of the final pp.
    public double pp_difficulty;
}

/// The result of a difficulty calculation on an osu!standard map.
[Serializable]
[StructLayout(LayoutKind.Sequential)]
public struct OsuDifficultyAttributes
{
    /// The difficulty of the aim skill.
    public double aim;

    /// The difficulty of the speed skill.
    public double speed;

    /// The difficulty of the flashlight skill.
    public double flashlight;

    /// The ratio of the aim strain with and without considering sliders
    public double slider_factor;

    /// The number of clickable objects weighted by difficulty.
    public double speed_note_count;

    /// The approach rate.
    public double ar;

    /// The overall difficulty
    public double od;

    /// The health drain rate.
    public double hp;

    /// The amount of circles.
    public uint n_circles;

    /// The amount of sliders.
    public uint n_sliders;

    /// The amount of spinners.
    public uint n_spinners;

    /// The final star rating
    public double stars;

    /// The maximum combo.
    public uint max_combo;
}

/// The result of a performance calculation on an osu!standard map.
[Serializable]
[StructLayout(LayoutKind.Sequential)]
public struct OsuPerformanceAttributes
{
    /// The difficulty attributes that were used for the performance calculation
    public OsuDifficultyAttributes difficulty;

    /// The final performance points.
    public double pp;

    /// The accuracy portion of the final pp.
    public double pp_acc;

    /// The aim portion of the final pp.
    public double pp_aim;

    /// The flashlight portion of the final pp.
    public double pp_flashlight;

    /// The speed portion of the final pp.
    public double pp_speed;

    /// Misses including an approximated amount of slider breaks
    public double effective_miss_count;
}

[Serializable]
[StructLayout(LayoutKind.Sequential)]
public struct PerformanceAttributes
{
    public OptionOsuPerformanceAttributes osu;
    public OptionTaikoPerformanceAttributes taiko;
    public OptionCatchPerformanceAttributes fruit;
    public OptionManiaPerformanceAttributes mania;
    public Mode mode;
}

/// Aggregation for a score's current state.
[Serializable]
[StructLayout(LayoutKind.Sequential)]
public struct ScoreState
{
    /// Maximum combo that the score has had so far. **Not** the maximum
    /// possible combo of the map so far.
    /// 
    /// Note that for osu!catch only fruits and droplets are considered for
    /// combo.
    /// 
    /// Irrelevant for osu!mania.
    public uint max_combo;

    /// Amount of current gekis (n320 for osu!mania).
    public uint n_geki;

    /// Amount of current katus (tiny droplet misses for osu!catch / n200 for
    /// osu!mania).
    public uint n_katu;

    /// Amount of current 300s (fruits for osu!catch).
    public uint n300;

    /// Amount of current 100s (droplets for osu!catch).
    public uint n100;

    /// Amount of current 50s (tiny droplets for osu!catch).
    public uint n50;

    /// Amount of current misses (fruits + droplets for osu!catch).
    public uint misses;
}

/// The result of a difficulty calculation on an osu!taiko map.
[Serializable]
[StructLayout(LayoutKind.Sequential)]
public struct TaikoDifficultyAttributes
{
    /// The difficulty of the stamina skill.
    public double stamina;

    /// The difficulty of the rhythm skill.
    public double rhythm;

    /// The difficulty of the color skill.
    public double color;

    /// The difficulty of the hardest parts of the map.
    public double peak;

    /// The perceived hit window for an n300 inclusive of rate-adjusting mods (DT/HT/etc)
    public double hit_window;

    /// The final star rating.
    public double stars;

    /// The maximum combo.
    public uint max_combo;

    /// Whether the [`BeatmapFile`] was a convert i.e. an osu!standard map.
    /// 
    /// [`BeatmapFile`]: crate::model::beatmapFile::BeatmapFile
    [MarshalAs(UnmanagedType.I1)] public bool is_convert;
}

/// The result of a performance calculation on an osu!taiko map.
[Serializable]
[StructLayout(LayoutKind.Sequential)]
public struct TaikoPerformanceAttributes
{
    /// The difficulty attributes that were used for the performance calculation
    public TaikoDifficultyAttributes difficulty;

    /// The final performance points.
    public double pp;

    /// The accuracy portion of the final pp.
    public double pp_acc;

    /// The strain portion of the final pp.
    public double pp_difficulty;

    /// Scaled miss count based on total hits.
    public double effective_miss_count;
}

public enum FFIError
{
    Ok = 0,
    Null = 100,
    Panic = 200,
    ParseError = 300,
    InvalidString = 400,
    Unknown = 1000
}

///A pointer to an array of data someone else owns which may not be modified.
[Serializable]
[StructLayout(LayoutKind.Sequential)]
public partial struct Sliceu8
{
    ///Pointer to start of immutable data.
    private IntPtr data;

    ///Number of elements.
    private ulong len;
}

public partial struct Sliceu8 : IEnumerable<byte>
{
    public Sliceu8(GCHandle handle, ulong count)
    {
        data = handle.AddrOfPinnedObject();
        len = count;
    }

    public Sliceu8(IntPtr handle, ulong count)
    {
        data = handle;
        len = count;
    }

    public byte this[int i]
    {
        get
        {
            if (i >= Count) throw new IndexOutOfRangeException();

            var size = Marshal.SizeOf(typeof(byte));
            var ptr = new IntPtr(data.ToInt64() + i * size);
            return Marshal.PtrToStructure<byte>(ptr);
        }
    }

    public byte[] Copied
    {
        get
        {
            var rval = new byte[len];

            for (var i = 0; i < (int)len; i++)
            {
                rval[i] = this[i];
            }

            return rval;
        }
    }

    public int Count => (int)len;

    public IEnumerator<byte> GetEnumerator()
    {
        for (var i = 0; i < (int)len; ++i)
        {
            yield return this[i];
        }
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }
}

///Option type containing boolean flag and maybe valid data.
[Serializable]
[StructLayout(LayoutKind.Sequential)]
public partial struct OptionCatchDifficultyAttributes
{
    ///Element that is maybe valid.
    private CatchDifficultyAttributes t;

    ///Byte where `1` means element `t` is valid.
    private byte is_some;
}

public partial struct OptionCatchDifficultyAttributes
{
    public static OptionCatchDifficultyAttributes FromNullable(CatchDifficultyAttributes? nullable)
    {
        var result = new OptionCatchDifficultyAttributes();

        if (nullable.HasValue)
        {
            result.is_some = 1;
            result.t = nullable.Value;
        }

        return result;
    }

    public CatchDifficultyAttributes? ToNullable()
    {
        return is_some == 1 ? t : null;
    }
}

///Option type containing boolean flag and maybe valid data.
[Serializable]
[StructLayout(LayoutKind.Sequential)]
public partial struct OptionCatchPerformanceAttributes
{
    ///Element that is maybe valid.
    private CatchPerformanceAttributes t;

    ///Byte where `1` means element `t` is valid.
    private byte is_some;
}

public partial struct OptionCatchPerformanceAttributes
{
    public static OptionCatchPerformanceAttributes FromNullable(CatchPerformanceAttributes? nullable)
    {
        var result = new OptionCatchPerformanceAttributes();

        if (nullable.HasValue)
        {
            result.is_some = 1;
            result.t = nullable.Value;
        }

        return result;
    }

    public CatchPerformanceAttributes? ToNullable()
    {
        return is_some == 1 ? t : null;
    }
}

///Option type containing boolean flag and maybe valid data.
[Serializable]
[StructLayout(LayoutKind.Sequential)]
public partial struct OptionManiaDifficultyAttributes
{
    ///Element that is maybe valid.
    private ManiaDifficultyAttributes t;

    ///Byte where `1` means element `t` is valid.
    private byte is_some;
}

public partial struct OptionManiaDifficultyAttributes
{
    public static OptionManiaDifficultyAttributes FromNullable(ManiaDifficultyAttributes? nullable)
    {
        var result = new OptionManiaDifficultyAttributes();

        if (nullable.HasValue)
        {
            result.is_some = 1;
            result.t = nullable.Value;
        }

        return result;
    }

    public ManiaDifficultyAttributes? ToNullable()
    {
        return is_some == 1 ? t : null;
    }
}

///Option type containing boolean flag and maybe valid data.
[Serializable]
[StructLayout(LayoutKind.Sequential)]
public partial struct OptionManiaPerformanceAttributes
{
    ///Element that is maybe valid.
    private ManiaPerformanceAttributes t;

    ///Byte where `1` means element `t` is valid.
    private byte is_some;
}

public partial struct OptionManiaPerformanceAttributes
{
    public static OptionManiaPerformanceAttributes FromNullable(ManiaPerformanceAttributes? nullable)
    {
        var result = new OptionManiaPerformanceAttributes();

        if (nullable.HasValue)
        {
            result.is_some = 1;
            result.t = nullable.Value;
        }

        return result;
    }

    public ManiaPerformanceAttributes? ToNullable()
    {
        return is_some == 1 ? t : null;
    }
}

///Option type containing boolean flag and maybe valid data.
[Serializable]
[StructLayout(LayoutKind.Sequential)]
public partial struct OptionOsuDifficultyAttributes
{
    ///Element that is maybe valid.
    private OsuDifficultyAttributes t;

    ///Byte where `1` means element `t` is valid.
    private byte is_some;
}

public partial struct OptionOsuDifficultyAttributes
{
    public static OptionOsuDifficultyAttributes FromNullable(OsuDifficultyAttributes? nullable)
    {
        var result = new OptionOsuDifficultyAttributes();

        if (nullable.HasValue)
        {
            result.is_some = 1;
            result.t = nullable.Value;
        }

        return result;
    }

    public OsuDifficultyAttributes? ToNullable()
    {
        return is_some == 1 ? t : null;
    }
}

///Option type containing boolean flag and maybe valid data.
[Serializable]
[StructLayout(LayoutKind.Sequential)]
public partial struct OptionOsuPerformanceAttributes
{
    ///Element that is maybe valid.
    private OsuPerformanceAttributes t;

    ///Byte where `1` means element `t` is valid.
    private byte is_some;
}

public partial struct OptionOsuPerformanceAttributes
{
    public static OptionOsuPerformanceAttributes FromNullable(OsuPerformanceAttributes? nullable)
    {
        var result = new OptionOsuPerformanceAttributes();

        if (nullable.HasValue)
        {
            result.is_some = 1;
            result.t = nullable.Value;
        }

        return result;
    }

    public OsuPerformanceAttributes? ToNullable()
    {
        return is_some == 1 ? t : null;
    }
}

///Option type containing boolean flag and maybe valid data.
[Serializable]
[StructLayout(LayoutKind.Sequential)]
public partial struct OptionTaikoDifficultyAttributes
{
    ///Element that is maybe valid.
    private TaikoDifficultyAttributes t;

    ///Byte where `1` means element `t` is valid.
    private byte is_some;
}

public partial struct OptionTaikoDifficultyAttributes
{
    public static OptionTaikoDifficultyAttributes FromNullable(TaikoDifficultyAttributes? nullable)
    {
        var result = new OptionTaikoDifficultyAttributes();

        if (nullable.HasValue)
        {
            result.is_some = 1;
            result.t = nullable.Value;
        }

        return result;
    }

    public TaikoDifficultyAttributes? ToNullable()
    {
        return is_some == 1 ? t : null;
    }
}

///Option type containing boolean flag and maybe valid data.
[Serializable]
[StructLayout(LayoutKind.Sequential)]
public partial struct OptionTaikoPerformanceAttributes
{
    ///Element that is maybe valid.
    private TaikoPerformanceAttributes t;

    ///Byte where `1` means element `t` is valid.
    private byte is_some;
}

public partial struct OptionTaikoPerformanceAttributes
{
    public static OptionTaikoPerformanceAttributes FromNullable(TaikoPerformanceAttributes? nullable)
    {
        var result = new OptionTaikoPerformanceAttributes();

        if (nullable.HasValue)
        {
            result.is_some = 1;
            result.t = nullable.Value;
        }

        return result;
    }

    public TaikoPerformanceAttributes? ToNullable()
    {
        return is_some == 1 ? t : null;
    }
}

public class BeatmapAttributesBuilder : IDisposable
{
    private IntPtr _context;

    private BeatmapAttributesBuilder() { }

    public IntPtr Context => _context;

    public void Dispose()
    {
        var rval = Rosu.beatmap_attributes_destroy(ref _context);

        if (rval != FFIError.Ok)
        {
            throw new InteropException<FFIError>(rval);
        }
    }

    public static BeatmapAttributesBuilder New()
    {
        var self = new BeatmapAttributesBuilder();
        var rval = Rosu.beatmap_attributes_new(ref self._context);

        if (rval != FFIError.Ok)
        {
            throw new InteropException<FFIError>(rval);
        }

        return self;
    }

    public void Mode(Mode mode)
    {
        Rosu.beatmap_attributes_mode(_context, mode);
    }

    public void PMods(IntPtr mods)
    {
        Rosu.beatmap_attributes_p_mods(_context, mods);
    }

    public void IMods(uint mods)
    {
        Rosu.beatmap_attributes_i_mods(_context, mods);
    }

    public void SMods(string str)
    {
        var rval = Rosu.beatmap_attributes_s_mods(_context, str);

        if (rval != FFIError.Ok)
        {
            throw new InteropException<FFIError>(rval);
        }
    }

    public void ClockRate(double clock_rate)
    {
        Rosu.beatmap_attributes_clock_rate(_context, clock_rate);
    }

    public void Ar(float ar)
    {
        Rosu.beatmap_attributes_ar(_context, ar);
    }

    public void Cs(float cs)
    {
        Rosu.beatmap_attributes_cs(_context, cs);
    }

    public void Hp(float hp)
    {
        Rosu.beatmap_attributes_hp(_context, hp);
    }

    public void Od(float od)
    {
        Rosu.beatmap_attributes_od(_context, od);
    }

    public double GetClockRate()
    {
        return Rosu.beatmap_attributes_get_clock_rate(_context);
    }

    public BeatmapAttributes Build(IntPtr beatmap)
    {
        return Rosu.beatmap_attributes_build(_context, beatmap);
    }
}

public class Beatmap : IDisposable
{
    private IntPtr _context;

    private Beatmap() { }

    public IntPtr Context => _context;

    public void Dispose()
    {
        var rval = Rosu.beatmap_destroy(ref _context);

        if (rval != FFIError.Ok)
        {
            throw new InteropException<FFIError>(rval);
        }
    }

    public static Beatmap FromBytes(Sliceu8 data)
    {
        var self = new Beatmap();
        var rval = Rosu.beatmap_from_bytes(ref self._context, data);

        if (rval != FFIError.Ok)
        {
            throw new InteropException<FFIError>(rval);
        }

        return self;
    }

    public static Beatmap FromPath(string path)
    {
        var self = new Beatmap();
        var rval = Rosu.beatmap_from_path(ref self._context, path);

        if (rval != FFIError.Ok)
        {
            throw new InteropException<FFIError>(rval);
        }

        return self;
    }

    /// Convert a BeatmapFile to the specified mode
    public bool Convert(Mode mode)
    {
        return Rosu.beatmap_convert(_context, mode);
    }

    public double Bpm()
    {
        return Rosu.beatmap_bpm(_context);
    }

    public double TotalBreakTime()
    {
        return Rosu.beatmap_total_break_time(_context);
    }
}

public class Difficulty : IDisposable
{
    private IntPtr _context;

    private Difficulty() { }

    public IntPtr Context => _context;

    public void Dispose()
    {
        var rval = Rosu.difficulty_destroy(ref _context);

        if (rval != FFIError.Ok)
        {
            throw new InteropException<FFIError>(rval);
        }
    }

    public static Difficulty New()
    {
        var self = new Difficulty();
        var rval = Rosu.difficulty_new(ref self._context);

        if (rval != FFIError.Ok)
        {
            throw new InteropException<FFIError>(rval);
        }

        return self;
    }

    public void PMods(IntPtr mods)
    {
        Rosu.difficulty_p_mods(_context, mods);
    }

    public void IMods(uint mods)
    {
        Rosu.difficulty_i_mods(_context, mods);
    }

    public void SMods(string str)
    {
        var rval = Rosu.difficulty_s_mods(_context, str);

        if (rval != FFIError.Ok)
        {
            throw new InteropException<FFIError>(rval);
        }
    }

    public void PassedObjects(uint passed_objects)
    {
        Rosu.difficulty_passed_objects(_context, passed_objects);
    }

    public void ClockRate(double clock_rate)
    {
        Rosu.difficulty_clock_rate(_context, clock_rate);
    }

    public void Ar(float ar)
    {
        Rosu.difficulty_ar(_context, ar);
    }

    public void Cs(float cs)
    {
        Rosu.difficulty_cs(_context, cs);
    }

    public void Hp(float hp)
    {
        Rosu.difficulty_hp(_context, hp);
    }

    public void Od(float od)
    {
        Rosu.difficulty_od(_context, od);
    }

    public void HardrockOffsets(bool hardrock_offsets)
    {
        Rosu.difficulty_hardrock_offsets(_context, hardrock_offsets);
    }

    public DifficultyAttributes Calculate(IntPtr beatmap)
    {
        return Rosu.difficulty_calculate(_context, beatmap);
    }

    public double GetClockRate()
    {
        return Rosu.difficulty_get_clock_rate(_context);
    }
}

public class Performance : IDisposable
{
    private IntPtr _context;

    private Performance() { }

    public IntPtr Context => _context;

    public void Dispose()
    {
        var rval = Rosu.performance_destroy(ref _context);

        if (rval != FFIError.Ok)
        {
            throw new InteropException<FFIError>(rval);
        }
    }

    public static Performance New()
    {
        var self = new Performance();
        var rval = Rosu.performance_new(ref self._context);

        if (rval != FFIError.Ok)
        {
            throw new InteropException<FFIError>(rval);
        }

        return self;
    }

    public void Mode(Mode mode)
    {
        Rosu.performance_mode(_context, mode);
    }

    public void PMods(IntPtr mods)
    {
        Rosu.performance_p_mods(_context, mods);
    }

    public void IMods(uint mods)
    {
        Rosu.performance_i_mods(_context, mods);
    }

    public void SMods(string str)
    {
        var rval = Rosu.performance_s_mods(_context, str);

        if (rval != FFIError.Ok)
        {
            throw new InteropException<FFIError>(rval);
        }
    }

    public void PassedObjects(uint passed_objects)
    {
        Rosu.performance_passed_objects(_context, passed_objects);
    }

    public void ClockRate(double clock_rate)
    {
        Rosu.performance_clock_rate(_context, clock_rate);
    }

    public void Ar(float ar)
    {
        Rosu.performance_ar(_context, ar);
    }

    public void Cs(float cs)
    {
        Rosu.performance_cs(_context, cs);
    }

    public void Hp(float hp)
    {
        Rosu.performance_hp(_context, hp);
    }

    public void Od(float od)
    {
        Rosu.performance_od(_context, od);
    }

    public void Accuracy(double accuracy)
    {
        Rosu.performance_accuracy(_context, accuracy);
    }

    public void Misses(uint misses)
    {
        Rosu.performance_misses(_context, misses);
    }

    public void Combo(uint combo)
    {
        Rosu.performance_combo(_context, combo);
    }

    public void HitresultPriority(HitResultPriority hitresult_priority)
    {
        Rosu.performance_hitresult_priority(_context, hitresult_priority);
    }

    public void N300(uint n300)
    {
        Rosu.performance_n300(_context, n300);
    }

    public void N100(uint n100)
    {
        Rosu.performance_n100(_context, n100);
    }

    public void N50(uint n50)
    {
        Rosu.performance_n50(_context, n50);
    }

    public void NKatu(uint n_katu)
    {
        Rosu.performance_n_katu(_context, n_katu);
    }

    public ScoreState GenerateState(IntPtr beatmap)
    {
        return Rosu.performance_generate_state(_context, beatmap);
    }

    public PerformanceAttributes Calculate(IntPtr beatmap)
    {
        return Rosu.performance_calculate(_context, beatmap);
    }

    public PerformanceAttributes CalculateFromDifficulty(DifficultyAttributes difficulty_attr)
    {
        return Rosu.performance_calculate_from_difficulty(_context, difficulty_attr);
    }

    public double GetClockRate()
    {
        return Rosu.performance_get_clock_rate(_context);
    }
}

public class OwnedString : IDisposable
{
    private IntPtr _context;

    private OwnedString() { }

    public IntPtr Context => _context;

    public void Dispose()
    {
        var rval = Rosu.string_destroy(ref _context);

        if (rval != FFIError.Ok)
        {
            throw new InteropException<FFIError>(rval);
        }
    }

    public static OwnedString FromCStr(string str)
    {
        var self = new OwnedString();
        var rval = Rosu.string_from_c_str(ref self._context, str);

        if (rval != FFIError.Ok)
        {
            throw new InteropException<FFIError>(rval);
        }

        return self;
    }

    public static OwnedString Empty()
    {
        var self = new OwnedString();
        var rval = Rosu.string_empty(ref self._context);

        if (rval != FFIError.Ok)
        {
            throw new InteropException<FFIError>(rval);
        }

        return self;
    }

    public bool IsInit()
    {
        return Rosu.string_is_init(_context);
    }

    public string ToCstr()
    {
        var s = Rosu.string_to_cstr(_context);
        return Marshal.PtrToStringAnsi(s);
    }
}

public class Mods : IDisposable
{
    private IntPtr _context;

    private Mods() { }

    public IntPtr Context => _context;

    public void Dispose()
    {
        var rval = Rosu.mods_destroy(ref _context);

        if (rval != FFIError.Ok)
        {
            throw new InteropException<FFIError>(rval);
        }
    }

    public static Mods FromAcronyms(string str)
    {
        var self = new Mods();
        var rval = Rosu.mods_from_acronyms(ref self._context, str);

        if (rval != FFIError.Ok)
        {
            throw new InteropException<FFIError>(rval);
        }

        return self;
    }

    public static Mods FromBits(uint bits)
    {
        var self = new Mods();
        var rval = Rosu.mods_from_bits(ref self._context, bits);

        if (rval != FFIError.Ok)
        {
            throw new InteropException<FFIError>(rval);
        }

        return self;
    }

    public uint Bits()
    {
        return Rosu.mods_bits(_context);
    }

    public bool IsEmpty()
    {
        return Rosu.mods_is_empty(_context);
    }

    public bool Contains(string str)
    {
        return Rosu.mods_contains(_context, str);
    }

    public bool Intersects(string str)
    {
        return Rosu.mods_intersects(_context, str);
    }

    public float LegacyClockRate()
    {
        return Rosu.mods_legacy_clock_rate(_context);
    }
}

public class InteropException<T> : Exception
{

    public InteropException(T error) : base($"Something went wrong: {error}")
    {
        Error = error;
    }

    public T Error { get; private set; }
}